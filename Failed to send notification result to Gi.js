Failed to send notification result to GitHub: ${i?.status} ${i?.statusText}`) } var gu = class { constructor(e, r) { this.token = e; this.organization_list = r; this.tokenMap = this.parseToken(e) } parseToken(e) { let r = new Map, i = e?.split(":")[0]?.split(";"); for (let o of i) { let [s, a] = o.split("="); r.set(s, a) } return r } get isInternal() { let e = ["4535c7beffc844b46bb1ed4aa04d759a", "a5db0bcaae94032fe715fb34a5e4bce2", "7184f66dfcee98cb5f08a1cb936d5225"]; if (!this.organization_list) return !1; for (let r of this.organization_list) if (e.includes(r)) return !0; return !1 } getTokenValue(e) { return this.tokenMap.get(e) } }, ir = class { constructor() { this.tokenRefreshEventEmitter = new g9.EventEmitter } }, xm = class extends ir { constructor(r, n) { super(); this.completionsToken = r; this.embeddingsToken = n; this.wasReset = !1 } async getGitHubToken() { return Promise.resolve("token") } async getCopilotToken(r, n) { return new gu(this.completionsToken) } async getEmbeddingsToken(r, n) { return new gu(this.embeddingsToken ?? this.completionsToken) } resetCopilotToken(r, n) { this.wasReset = !0 } async checkCopilotToken(r) { return { status: "OK" } } }, aT = class extends ir { constructor(r) { super(); this.githubToken = r; this.copilotToken = void 0 } async getGitHubToken() { return Promise.resolve(this.githubToken.token) } async getCopilotToken(r, n) { if (!this.copilotToken || this.copilotToken.expires_at < ic() || n) { let i = await sT(r, this.githubToken); if (i.kind === "failure") throw Error(`Failed to get copilot token: ${i.reason.toString()} ${i.message ?? ""}`); this.copilotToken = { ...i }, cT(r, this, i.refresh_in) } return new gu(this.copilotToken.token, this.copilotToken.organization_list) } async checkCopilotToken(r) { if (!this.copilotToken || this.copilotToken.expires_at < ic()) { let i = await sT(r, this.githubToken); if (i.kind === "failure") return i; this.copilotToken = { ...i }, cT(r, this, i.refresh_in) } return { status: "OK" } } resetCopilotToken(r, n) { n !== void 0 && r.get(rt).sendTelemetry("auth.reset_token_" + n), uT(r).debug(`Resetting copilot token on HTTP error ${n || "unknown"}`), this.copilotToken = void 0 } }, h9 = new WeakMap; function cT(t, e, r) { let n = ic(), i = h9.get(e) ?? h9.set(e, { value: 0 }).get(e); i.value > 0 || (i.value++, setTimeout(async () => { let o, s = ""; try { i.value--, await e.getCopilotToken(t, !0), o = "success", e.tokenRefreshEventEmitter.emit(qEe) } catch (u) { o = "failure", s = u.toString() } let a = Nt.createAndMarkAsIssued({ result: o }, { time_taken: ic() - n, refresh_count: i.value }); s && (a.properties.reason = s), t.get(rt).sendTelemetry("auth.token_refresh", a) }, r * 1e3)) } var oc = new class { constructor() { this.commands = new Set } registerCommand(t) { this.commands.add(t) } getCommand(t, e) { return this.getCommands(e).find(r => r.commandId === t) } getCommands(t) { return Array.from(this.commands.values()).filter(e => e.location & t) } }; var sc = class { constructor(e) { this.accessor = e; this.commandPrefix = "/"; this.readConfig() } readConfig() { this._enabledCommands = Gt(this.accessor, Me.ConversationSlashCommandEnablements, { default: { "*": !1 } }) } isCommandEnabled(e, r) { if (this._enabledCommands === void 0) return !1; if (this._enabledCommands[e] === void 0) { if (this._enabledCommands["*"]) return !0; let n = oc.getCommand(e, r)?.intent?.defaultEnablement; return typeof n == "boolean" ? n : !0 } return !!this._enabledCommands[e] } parse(e, r) { if (e.startsWith(this.commandPrefix)) { let n = e.indexOf(" "), i = n === -1 ? e.length : n, o = e.substring(this.commandPrefix.length, i), s = oc.getCommand(o, r); if (this.readConfig(), s && this.isCommandEnabled(o, r)) { let a = e.substring(i).trim(); return { command: s, restOfQuery: a } } } return { restOfQuery: e } } allCommands(e) { return this.readConfig(), oc.getCommands(e).filter(r => this.isCommandEnabled(r.commandId, e)) } }; var Ke = new class { constructor() { this._contextResolvers = [] } get contextResolvers() { return this._contextResolvers } register(t) { Array.isArray(t) ? this._contextResolvers.push(...t) : this._contextResolvers.push(t) } }; var Rp = class { constructor(e) { this._variableEnablements = Gt(e, Me.ConversationVariablesEnablements, { default: { "*": !1 } }) } isVariableEnabled(e) { return typeof this._variableEnablements[e] == "boolean" ? this._variableEnablements[e] : !!this._variableEnablements["*"] } getVariables() { return Ke.contextResolvers.filter(e => e.variableName && this.isVariableEnabled(e.variableName)).map(e => ({ name: e.variableName, description: e.variableDescription, resolve: e.resolveContext.bind(e) })) } }; var y9 = require("crypto"); var v9 = De(require("util")); var bm = Ui("IExperimentationService"), lT = class { constructor() { this.initializePromise = Promise.resolve(); this.initialFetch = Promise.resolve() } isFlightEnabled(e) { return !1 } isCachedFlightEnabled(e) { return Promise.resolve(!1) } isFlightEnabledAsync(e) { return Promise.resolve(!1) } getTreatmentVariable(e, r) { } getTreatmentVariableAsync(e, r) { return Promise.resolve(void 0) } }; var VEe = "https://copilot-proxy.githubusercontent.com/v1"; async function GEe(t) { let e = Fn(t, Me.DebugTestOverrideProxyUrl), r = k0(t); if (r && e.length > 0) return e; let n = Fn(t, Me.DebugChatOverrideProxyUrl) ?? Fn(t, Me.DebugOverrideProxyUrl); return await t.get(bm).getTreatmentVariableAsync("vscode", "copilotchat.capi.completions", !0) || r || Fn(t, Me.UseCAPI) ? "https://api.githubcopilot.com/chat" : n } async function zEe(t, e) { let r = await GEe(t); return r.length === 0 ? (r = VEe, `${r}${e}`) : r } async function $Ee(t) { return zEe(t, "/chat") } async function KEe(t) { return await t.get(bm).getTreatmentVariableAsync("vscode", "copilotchat.capi.embeddings", !0) || Fn(t, Me.UseCAPI) || k0(t) ? "https://api.githubcopilot.com/embeddings" : "https://copilot-proxy.githubusercontent.com/v1/embeddings" } async function WEe(t) { let e = Gt(t, Me.DebugOverrideChatMaxTokenNum, { default: 0 }); if (e > 0) return e; let r = await t.get(rn).chatMaxNumTokens(); return r > 0 ? r : 4096 } async function YEe(t) { let e = Gt(t, Me.DebugOverrideChatEngine, { default: "" }); if (e) return e; let r = await t.get(rn).chatExpModel(); return r || "copilot-chat" } var Cn = class { constructor(e, r) { this.accessor = e; this._modelOverride = r } async getChatEndpointInfo() { if (this._chatEndpoint) return this._chatEndpoint; let e = await $Ee(this.accessor), r = await WEe(this.accessor), n = this._modelOverride ?? await YEe(this.accessor); return this._chatEndpoint = new py(e, "completions", n, r), this._chatEndpoint } async getEmbeddingsEndpointInfo() { if (this._embeddingsEndpoint) return this._embeddingsEndpoint; let e = await KEe(this.accessor); return this._embeddingsEndpoint = new tO(e), this._embeddingsEndpoint } }, py = class { constructor(e, r, n, i) { this.engineUrl = e; this.endpoint = r; this._maxTokens = i ?? 4096, this.model = n ?? "copilot-chat" } get modelMaxTokenWindow() { return this._maxTokens } get engineName() { let e = this.engineUrl.split("/").pop(); return e || this.engineUrl } get url() { return v9.format("%s/%s", this.engineUrl, this.endpoint) } getExtraHeaders(e) { return { "Openai-Organization": "github-copilot" } } }, tO = class { constructor(e) { this.url = e; this.supportsBatching = !1 } getExtraHeaders(e) { return { "Openai-Organization": "github-copilot" } } }; var sn = Ui("IEmbeddingsComputer"), Em = class { constructor(e) { this.accessor = e } async computeEmbeddings(e, r) { this._embeddingEndpoint || (this._embeddingEndpoint = await this.accessor.get(Cn).getEmbeddingsEndpointInfo()); let n = this._embeddingEndpoint.supportsBatching ? 300 : 1; return this.fetchResponseWithBatches(e, r, n) } async fetchResponseWithBatches(e, r, n = 0) { let i = n, o = []; for (let s = 0; s < e.length; s += i) { let a = e.slice(s, s + i), u = await this.rawEmbeddingsFetch(this.accessor, (0, y9.randomUUID)(), a, r); if (u.type === "failed") return u.reason === "timeout" && i > 200 ? (console.error("Timeout fetching embeddings, retrying with smaller batch size"), this.fetchResponseWithBatches(e, r, i - 100)) : void 0; o.push(...u.embeddings) } return o.length === 0 ? void 0 : o } async rawEmbeddingsFetch(e, r, n, i) { this._embeddingEndpoint || (this._embeddingEndpoint = await this.accessor.get(Cn).getEmbeddingsEndpointInfo()); try { let o = e.get(ir), s = o instanceof xm ? await o.getEmbeddingsToken(e) : await o.getCopilotToken(e), a = { input: n, model: "copilot-text-embedding-ada-002" }; this._embeddingEndpoint.interceptBody?.(a); let u = await C0(e, this._embeddingEndpoint, s.token, "copilot-panel", r, a, i), c = await u.json(); return u.status === 200 && c.data ? { type: "success", embeddings: c.data.map(l => l.embedding) } : { type: "failed", reason: c.error } } catch (o) { let s = o?.message ?? "Unknown error"; return s.match(/Unexpected.*JSON/i) && (s = "timeout"), { type: "failed", reason: s } } } }; var WY = require("crypto"), YT = require("path"), YY = require("util"); var oi = class { }; var pT = class { constructor(e, r) { this.baseUri = e; this.pattern = r } get base() { throw new Error("Not implemented") } }; var rO = class { constructor(e, r) { this.uri = e; this.value = r } }, XEe, ea = class t { constructor(e, r) { this[XEe] = "ResourceMap"; e instanceof t ? (this.map = new Map(e.map), this.toKey = r ?? t.defaultToKey) : (this.map = new Map, this.toKey = e ?? t.defaultToKey) } static { this.defaultToKey = e => e.toString() } set(e, r) { return this.map.set(this.toKey(e), new rO(e, r)), this } get(e) { return this.map.get(this.toKey(e))?.value } has(e) { return this.map.has(this.toKey(e)) } get size() { return this.map.size } clear() { this.map.clear() } delete(e) { return this.map.delete(this.toKey(e)) } forEach(e, r) { typeof r < "u" && (e = e.bind(r)); for (let [n, i] of this.map) e(i.value, i.uri, this) } *values() { for (let e of this.map.values()) yield e.value } *keys() { for (let e of this.map.values()) yield e.uri } *entries() { for (let e of this.map.values()) yield [e.uri, e.value] } *[(XEe = Symbol.toStringTag, Symbol.iterator)]() { for (let [, e] of this.map) yield [e.uri, e.value] } }; var si = class { }; var kt = Ui("IPromptContextModel"); var zn = class extends Ve {
		constructor(e, r) { super(e, r) } debug(e, ...r) { vu(this.accessor) && super.debug(e, ...r) } logPrompt(e) {
			if (!vu(this.accessor)) return; let r = `
---------------------------------
`; super.info(r + e.map(n => `${n.role.toUpperCase()}:
${n.content}`).join(r) + r)
		} logResponse(e) {
			if (!vu(this.accessor)) return; let r = `
---------------------------------
`; if (typeof e != "string") { if (e.type !== "success") { super.info(`${r}RESPONSE FAILED DUE TO ${e.type}${r}`); return } Array.isArray(e.value) ? e.value.length === 1 ? e = e.value[0] : e = `${e.value.map(n => `<<${n}>>`).join(", ")}` : e = e.value } super.info(`${r}ASSISTANT:
${e}${r}`)
		} info(e, ...r) { vu(this.accessor) && super.info(e, ...r) } warn(e, ...r) { vu(this.accessor) && super.warn(e, ...r) } errorAndSendTelemetry(e, ...r) { vu(this.accessor) && super.errorAndSendTelemetry(e, ...r) }
	}; function vu(t) { return !!Gt(t, Me.ConversationLoggingEnabled, { default: !1 }) } var Ft = class { }; var VY = De(require("tls")); var qY = De(require("fs")); var yu = class { constructor() { this.cache = new Map } get(e) { return this.cache.get(e) } set(e, r) { this.cache.set(e, r) } }; var _u = class { async loadCaCerts() { } }; var pi = class { }, HY = (t, e = process.platform) => new uD(t.get(Wn), MIe(e, t), new vD), uD = class extends pi { constructor(r, n, i) { super(); this.realReader = n; this.noopReader = i; this.delegate = n, r.on("onCopilotToken", o => { this.delegate = o.getTokenValue("ssc") === "1" ? this.realReader : this.noopReader }) } getAllRootCAs() { return this.delegate.getAllRootCAs() } }, MIe = (t, e) => { let r = e.get(yu).get(t); if (r) return r; let n = FIe(t, e), i = new dD(n), o = new pD(i), s = new lD(e, o); return e.get(yu).set(t, s), s }, FIe = (t, e) => { switch (t) { case "linux": return new fD; case "darwin": return new mD; case "win32": return new hD(e); default: return new gD } }, lD = class extends pi { constructor(r, n) { super(); this.accessor = r; this.delegate = n } async getAllRootCAs() { try { return await this.delegate.getAllRootCAs() } catch (r) { return new Ve(this.accessor, "certificates").warn(`Failed to read root certificates: ${r}`), [] } } }, pD = class extends pi { constructor(r) { super(); this.delegate = r } async getAllRootCAs() { return this.certificates || (this.certificates = await this.delegate.getAllRootCAs()), this.certificates } }, dD = class extends pi { constructor(r) { super(); this.delegate = r } async getAllRootCAs() { let r = await this.delegate.getAllRootCAs(), n = process.env.NODE_EXTRA_CA_CERTS; if (!n) return r; let i = await jY(n); return r.concat(i) } }, fD = class extends pi { async getAllRootCAs() { let e = []; for (let r of ["/etc/ssl/certs/ca-certificates.crt", "/etc/ssl/certs/ca-bundle.crt"]) { let n = await jY(r); e = e.concat(n) } return e } }, mD = class extends pi { async getAllRootCAs() { let e = UY(); return e.all(e.der2.pem).filter(r => r !== void 0) } }, hD = class extends pi { constructor(r) { super(); this.accessor = r } async getAllRootCAs() { return await this.accessor.get(_u).loadCaCerts() || [] } }, gD = class extends pi { async getAllRootCAs() { throw new Error("No certificate reader available for unsupported platform") } }, vD = class extends pi { async getAllRootCAs() { return [] } }; async function jY(t) { try { let n = (await qY.promises.readFile(t, { encoding: "utf8" })).split(/(?=-----BEGIN CERTIFICATE-----)/g).filter(o => o.length > 0), i = new Set(n); return Array.from(i) } catch (e) { if (e?.code !== "ENOENT") throw e } return [] } var $T = class { constructor(e) { this._certificateReader = e.get(pi) } async enhanceProxySettings(e) { let r = await this.getCertificates(); return { ...e, ca: r } } async getCertificates() { let e = await this._certificateReader.getAllRootCAs(); if (e.length !== 0) return e } async applyToRequestOptions(e) { let r = await this._certificateReader.getAllRootCAs(), n = { _vscodeAdditionalCaCerts: r }; e.secureContext = VY.createSecureContext(n), e.ca = r, e.cert = r, r.map(i => { e.secureContext.context.addCACert(i) }) } }; var GY = De(require("http")); var Nu = class { async loadKerberos() { } }; var BIe = 407, ku = class { }, pc = class extends Error { constructor(r, n, i) { super(r); this.cause = n; this.responseStatus = i } }; function zY(t) { return new yD(t, new _D(t)) } var yD = class extends ku { constructor(r, n, i = process.platform) { super(); this.accessor = r; this.delegate = n; this.platform = i; this.successfullyAuthorized = new Pl(20); this.logger = new Ve(r, "proxy-socket-factory") } async createSocket(r, n) { this.successfullyAuthorized.get(this.getProxyCacheKey(n)) && (this.logger.debug("Proxy authorization already successful once, skipping 407 rountrip"), await this.reauthorize(r, n)); try { return await this.delegate.createSocket(r, n) } catch (i) { if (i instanceof pc && i.responseStatus === BIe) { this.logger.debug("Proxy authorization required, trying to authorize first time"); let o = await this.authorizeAndCreateSocket(r, n); if (o) return this.logger.debug("Proxy authorization successful, caching result"), this.successfullyAuthorized.put(this.getProxyCacheKey(n), !0), o } throw i } } async reauthorize(r, n) { let i = await this.authorize(n); i && (this.logger.debug("Proxy re-authorization successful, received token"), r.headers["Proxy-Authorization"] = "Negotiate " + i) } async authorizeAndCreateSocket(r, n) { let i = await this.authorize(n); if (this.logger.debug("Proxy authorization successful, received token"), i) return this.logger.debug("Trying to create socket with proxy authorization"), r.headers["Proxy-Authorization"] = "Negotiate " + i, await this.delegate.createSocket(r, n) } async authorize(r) { this.logger.debug("Loading kerberos module"); let n = await UIe(this.accessor); if (!n) { this.logger.debug("Could not load kerberos module"); return } let i = this.computeSpn(r); this.logger.debug("Initializing kerberos client using spn", i); let o = await n.initializeClient(i); this.logger.debug("Perform client side kerberos step"); let s = await o.step(""); return this.logger.debug("Received kerberos server response"), s } computeSpn(r) { let n = Gt(this.accessor, Me.KerberosServicePrincipal, { default: r.kerberosServicePrincipal }); if (n) return this.logger.debug("Using configured kerberos spn", n), n; let i = this.platform === "win32" ? `HTTP/${r.host}` : `HTTP@${r.host}`; return this.logger.debug("Using default kerberos spn", i), i } getProxyCacheKey(r) { return r.host + ":" + r.port } }, _D = class extends ku { constructor(r) { super(); this.logger = new Ve(r, "proxy-socket-factory") } async createSocket(r, n) { let i = this.createConnectRequestOptions(r, n); return new Promise((o, s) => { this.logger.debug("Attempting to establish connection to proxy"); let a = GY.request(i); a.useChunkedEncodingByDefault = !1, a.once("connect", (u, c, l) => { this.logger.debug("Socket Connect returned status code", u.statusCode), a.removeAllListeners(), c.removeAllListeners(), u.statusCode !== 200 ? (c.destroy(), s(new pc("tunneling socket could not be established", void 0, u.statusCode))) : l.length > 0 ? (c.destroy(), s(new pc("got illegal response body from proxy"))) : (this.logger.debug("Successfully established tunneling connection to proxy"), o(c)) }), a.once("error", u => { this.logger.debug("Proxy socket connection error", u.message), a.removeAllListeners(), s(new pc("tunneling socket could not be established", u)) }), a.on("timeout", () => { this.logger.debug("Proxy socket connection timeout"), s(new pc(`tunneling socket could not be established, proxy socket connection timeout while connecting to ${i.host}:${i.port}`)) }), a.end() }) } createConnectRequestOptions(r, n) { let i = { ...n, method: "CONNECT", path: r.host + ":" + r.port, agent: !1, headers: { host: r.host + ":" + r.port, "Proxy-Connection": "keep-alive" }, timeout: r.timeout }; return r.localAddress && (i.localAddress = r.localAddress), this.configureProxyAuthorization(i, r), i } configureProxyAuthorization(r, n) { r.headers["Proxy-Authorization"] = [], r.proxyAuth && r.headers